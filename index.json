[{"uri":"/sponsors.html","title":"Sponsors","content":"\n# Our Sponsors\n\nIonide couldn't be created without the support of [Lambda Factory](https://lambdafactory.io). If your company would be interested in supporting development of Ionide, or acquiring commercial support send us an email - lambda_factory@outlook.com.\n\nYou can also support Ionide development on [Open Collective](https://opencollective.com/ionide). [![Open Collective](https://opencollective.com/ionide/donate/button.png?color=blue)](https://opencollective.com/ionide)\n\n### Partners\n\n<div align=\"center\">\n\n<a href=\"https://lambdafactory.io\"><img src=\"https://cdn-images-1.medium.com/max/332/1*la7_YvDFvrtA720P5bYWBQ@2x.png\" alt=\"drawing\" width=\"100\"/></a>\n\n</div>\n\n### Sponsors\n\n[Become a sponsor](https://opencollective.com/ionide) and get your logo on our README on Github, description in the VSCode marketplace and on [ionide.io](http://ionide.io) with a link to your site.\n\n<div align=\"center\">\n    <object type=\"image/svg+xml\" data=\"https://opencollective.com/ionide/tiers/silver-sponsor.svg?avatarHeight=120&width=1000&button=false\"></object>\n    <br/>\n    <object type=\"image/svg+xml\" data=\"https://opencollective.com/ionide/tiers/bronze-sponsor.svg?avatarHeight=70&width=1000&button=false\"></object>\n</div>\n"},{"uri":"/index.html","title":"Home","content":"\n# Ionide\n\n<img heigh=\"100\" width=\"100\" src=\"static/images/logo.png\" />\n\nIonide is an organization which builds **high quality, cross platform developer tools for F#**. Our flagship project is Ionide-VSCode - a Visual Studio Code plugin, with more than 1 million downloads, transforming VSCode into a **fully-fledged F# IDE**. But Ionide is more then just an editor plugin - we build a whole ecosystem of developer tools - from a [documentation generator](Tools/fornax.html), to an [F# LSP server](Tools/fsac.html), to experimental and innovative projects like [F# Analyzers](Libraries/fsanalyzers.html).\n\n<img class=\"gif\" src=\"static/images/fsharp.gif\" />\n\n\n### Our goals and motivations\n\n> We build cross platform, F# developer tooling\n\n* Provide cross platform, open source developer tooling for F#\n* Provide high quality IDE experience\n* Innovate in the area of development tooling for F# / FP languages\n* Provide a set of opinionated tools that work well together\n* Focus on UX, everything should Just Work (tm)\n* Contribute to the general F# OSS ecosystem\n\n"},{"uri":"/callToAction.html","title":"Call To Action","content":"\n# Call to Action\n\n## How to contribute\n\n*Imposter syndrome disclaimer*: I want your help. No really, I do.\n\nThere might be a little voice inside that tells you you're not ready; that you need to do one more tutorial, or learn another framework, or write a few more blog posts before you can help me with this project.\n\nI assure you, that's not the case.\n\nAll Ionide projects have some clear Contribution Guidelines and expectations that you can find in every repo - [example here](https://github.com/ionide/ionide-vscode-fsharp/blob/master/CONTRIBUTING.md).\n\nThe contribution guidelines outline the process that you'll need to follow to get a patch merged. By making expectations and processes explicit, I hope it will make it easier for you to contribute.\n\nAnd you don't just have to write code. You can help out by writing documentation, tests, or even by giving feedback about this work. (And yes, that includes giving feedback about the contribution guidelines.)\n\nThank you for contributing!\n\n## Contributing and copyright\n\nAll Ionide projects are hosted on [GitHub](https://github.com/ionide) where you can report issues, fork the project and submit pull requests.\n\nAll projects are avaliable available under an OSS license ([usually MIT](https://github.com/ionide/ionide-vscode-fsharp/blob/master/LICENSE.md)), which allows modification and redistribution for both commercial and non-commercial purposes.\n\nPlease note that all Ionide projects are released with a [Contributor Code of Conduct](https://github.com/ionide/ionide-vscode-fsharp/blob/master/CODE_OF_CONDUCT.md). By participating in this project you agree to abide by its terms.\n"},{"uri":"/Libraries/fsanalyzers.html","title":"FSharp.Analyzers.SDK","content":"\n# FSharp.Analyzers.SDK\n\n**GitHub link:** [https://github.com/ionide/FSharp.Analyzers.SDK](https://github.com/ionide/FSharp.Analyzers.SDK)\n**License:** [MIT](https://github.com/ionide/FSharp.Analyzers.SDK/blob/master/LICENSE.md)\n\n`FSharp.Analyzers.SDK` is a library used for building custom analyzers for FSAC / F# editors. F# analyzers are live, real-time, project-based plugins that enables diagnosis of source code and surfacing of custom errors, warnings and code fixes into the editor. They're heavily influenced and inspired by [Roslyn Analyzers](https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview?view=vs-2019).\n\nRead more about F# Analyzers here - [https://medium.com/lambda-factory/introducing-f-analyzers-772487889429](https://medium.com/lambda-factory/introducing-f-analyzers-772487889429)\n\n## Writing Analyzers\n\nAnalyzers that are consumed by this SDK and from Ionide are simply .NET core class libraries. These class libraries expose a *value* of type `Analyzer` which is effectively a function that has input of type `Context` and returns a list of `Message` records:\n\n```fsharp\nmodule BadCodeAnalyzer\n\nopen FSharp.Analyzers.SDK\n\n[<Analyzer>]\nlet badCodeAnalyzer : Analyzer =\n  fun (context: Context) =\n    // inspect context to determine the error/warning messages\n    [   ]\n```\n\nNotice how we expose the function `BadCodeAnalyzer.badCodeAnalyzer` with an attribute `[<Analyzer>]` that allows the SDK to detect the function. The input `Context` is a record that contains information about a single F# file such as the typed AST, the AST, the file content, the file name and more. The SDK runs this function against all files of a project during editing. The output messages that come out of the function are eventually used by Ionide to highlight the inspected code as a warning or error depending on the `Severity` level of each message.\n\n### Analyzer Requirements\n\nAnalyzers are .NET Core class libraries and they are distributed as such. However, since the SDK relies on dynamically loading the analyzers during runtime, there are some requirements to get them to work properly:\n - The analyzer class library has to target the `netcoreapp2.0` framework\n - The analyzer has to reference the latest `FSharp.Analyzers.SDK` (at least the version used by FsAutoComplete which is subsequently used by Ionide)\n\n### Packaging and Distribution\n\nSince analyzers are just .NET core libraries, you can distribute them to the nuget registry just like you would with a normal .NET package. Simply run `dotnet pack --configuration Release` against the analyzer project to get a nuget package and publish it with\n\n```\ndotnet nuget push {NugetPackageFullPath} -s nuget.org -k {NugetApiKey}\n```\n\nHowever, the story is different and slightly more complicated when your analyzer package has third-party dependencies also coming from nuget. Since the SDK dynamically loads the package assemblies (`.dll` files), the assemblies of the dependencies has be located *next* to the main assembly of the analyzer. Using `dotnet pack` will **not** include these dependencies into the output Nuget package. More specifically, the `./lib/netcoreapp2.0` directory of the nuget package must have all the required assemblies, also those from third-party packages. In order to package the analyzer properly with all the assemblies, you need to take the output you get from running:\n\n```\ndotnet publish --configuration Release --framework netcoreapp2.0\n```\n\nagainst the analyzer project and put every file from that output into the `./lib/netcoreapp2.0` directory of the nuget package. This requires some manual work by unzipping the nuget package first (because it is just an archive), modifying the directories then zipping the package again. It can be done using a FAKE build target to automate the work:\n\n```fsharp\n// make ZipFile available\n#r \"System.IO.Compression.FileSystem.dll\"\n\nlet releaseNotes = ReleaseNotes.load \"RELEASE_NOTES.md\"\n\nTarget.create \"PackAnalyzer\" (fun _ ->\n    let analyzerProject = \"src\" </> \"BadCodeAnalyzer\"\n    let args =\n        [\n            \"pack\"\n            \"--configuration Release\"\n            sprintf \"/p:PackageVersion=%s\" releaseNotes.NugetVersion\n            sprintf \"/p:PackageReleaseNotes=\\\"%s\\\"\" (String.concat \"\\n\" releaseNotes.Notes)\n            sprintf \"--output %s\" (__SOURCE_DIRECTORY__ </> \"dist\")\n        ]\n\n    // create initial nuget package\n    let exitCode = Shell.Exec(\"dotnet\", String.concat \" \" args, analyzerProject)\n    if exitCode <> 0 then\n        failwith \"dotnet pack failed\"\n    else\n        match Shell.Exec(\"dotnet\", \"publish --configuration Release --framework netcoreapp2.0\", analyzerProject) with\n        | 0 ->\n            let nupkg =\n                System.IO.Directory.GetFiles(__SOURCE_DIRECTORY__ </> \"dist\")\n                |> Seq.head\n                |> IO.Path.GetFullPath\n\n            let nugetParent = DirectoryInfo(nupkg).Parent.FullName\n            let nugetFileName = IO.Path.GetFileNameWithoutExtension(nupkg)\n\n            let publishPath = analyzerProject </> \"bin\" </> \"Release\" </> \"netcoreapp2.0\" </> \"publish\"\n            // Unzip the nuget\n            ZipFile.ExtractToDirectory(nupkg, nugetParent </> nugetFileName)\n            // delete the initial nuget package\n            File.Delete nupkg\n            // remove stuff from ./lib/netcoreapp2.0\n            Shell.deleteDir (nugetParent </> nugetFileName </> \"lib\" </> \"netcoreapp2.0\")\n            // move the output of publish folder into the ./lib/netcoreapp2.0 directory\n            Shell.copyDir (nugetParent </> nugetFileName </> \"lib\" </> \"netcoreapp2.0\") publishPath (fun _ -> true)\n            // re-create the nuget package\n            ZipFile.CreateFromDirectory(nugetParent </> nugetFileName, nupkg)\n            // delete intermediate directory\n            Shell.deleteDir(nugetParent </> nugetFileName)\n        | _ ->\n            failwith \"dotnet publish failed\"\n)\n```\n"},{"uri":"/Libraries/eventhorizon.html","title":"Ionide.EventHorizon","content":"\n# Ionide.EventHorizon\n\n**GitHub link:** [https://github.com/ionide/FSharp.EventHorizon](https://github.com/ionide/FSharp.EventHorizon)\n**License:** [MIT](https://github.com/ionide/FSharp.EventHorizon/blob/master/LICENSE.md)\n\nAn **experiment** attempting to implement `type holes` and `type-directed search`/`valid hole fits` using F# analyzers. Long story short, it's an attempt at suggesting replacements for  unknown functions using type inference, as well as finding other entities that have matching type signatures.\n\n- Read more about `type holes`: [https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/typed-holes.html](https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/typed-holes.html)\n- Read more about `type-directed search` in PureScript: [https://github.com/paf31/24-days-of-purescript-2016/blob/master/23.markdown](https://github.com/paf31/24-days-of-purescript-2016/blob/master/23.markdown)\n- Read more about `valid hole fits` in GHC: [https://mpg.is/papers/gissurarson2018suggesting.pdf](https://mpg.is/papers/gissurarson2018suggesting.pdf)\n\nUnlike some of the solutions for other FP languages, this is not a feature implemented directly in compiler, nor is it a feature of any particular IDE; rather it's using F# Analyzers.\n\nRead more about F# Analyzers:\n  - Intro blog post - [https://medium.com/lambda-factory/introducing-f-analyzers-772487889429](https://medium.com/lambda-factory/introducing-f-analyzers-772487889429)\n  - FSharp.Analyzers.SDK repo - [https://github.com/ionide/FSharp.Analyzers.SDK](https://github.com/ionide/FSharp.Analyzers.SDK)\n  - Sample analyzer implementation - [https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.Sample](https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.Sample)\n  - Sample repo showing how to use analyzers - [https://github.com/Krzysztof-Cieslak/AnalyzersShowcase](https://github.com/Krzysztof-Cieslak/AnalyzersShowcase)\n\n<img class=\"gif\" src=\"/static/images/EventHorizon.png\" />\n\n## Limitations\n\nF# Compiler Service does not expose any API for `subsumption of types`. I've implemented a really naive algorithm to check if an entity can fit a given type hole... but well, it's definitely not following the rules of the F# compiler 100%, so not every suggestion is found.\n\nI think that this limitation is acceptable given that the project is in an experimental phase - if it were productized, we would need to expose those missing APIs from F# Compiler Services, so investing more into a custom algorithm here would be a waste of time.\n"},{"uri":"/Libraries/waypoint.html","title":"Waypoint","content":"\n# Waypoint\n\n**GitHub link:** [https://github.com/ionide/Waypoint](https://github.com/ionide/Waypoint)\n**License:** [MIT](https://github.com/ionide/Waypoint/blob/master/LICENSE.md)\n\nOpinionated solution template for building F# OSS libraries and tools.\n\nSample repository is available here - https://github.com/Krzysztof-Cieslak/SampleWaypoint\n\nSample generated documentation can be found here - http://kcieslak.io/SampleWaypoint\n\n## What's included in template\n\n* Paket, FAKE, and Fornax added as `dotnet` local tools (`.config/dotnet-tools.json`)\n* `build.fsx` file, containing default FAKE script with targets for building, testing, documentation generation, publishing to GitHub, and publishing to NuGet\n* `paket.dependencies` with basic set of dependencies\n* `src` folder containing 2 projects - one class library (`netstandard2.0`), and CLI tool (`netcoreapp3.1`)\n* `test` folder containing UnitTest project using Expecto and FsCheck\n* `docs` folder with Fornax documentation template that will generate nice documentation for your project.\n* `.devcontainer` folder with definition of [Development Container](https://code.visualstudio.com/docs/remote/containers)\n* `.github/workflows` folder with definition for 2 GitHub actions - one for building and testing code as CI, one for deploying documentation when new tag is pushed. To use latter, you need to define `PERSONAL_TOKEN` secret in GitHub repo settings with Personal Access Token.\n* `.github/ISSUE_TEMPLATE` folder with 2 different issue templates - one for bug report, other one for feature request\n\n## Documentation Theme\n\nTemplate includes, out-of-the-box, nice theme for your project documentation, which integrates with FSharp.Formatting to create also API reference\n\n* Sample documentation produced by the template can be found on http://kcieslak.io/SampleWaypoint.\n* Created theme is partial port to Fornax of [Hugo Learn theme](https://learn.netlify.com/en/).\n* You define content as markdown files\n* Support for unlimited multi-level navigation\n* Use FSharp.Formatting to create API reference for the project - sample: http://kcieslak.io/SampleWaypoint/Reference/ApiRef.html\n* Use [Lunr.js](https://lunrjs.com/) to provide client side search based on generated by Fornax search index - sample: try searching for `Lorem` or `Sample` in search available on http://kcieslak.io/SampleWaypoint\n* Use [Mermaid.js](https://mermaid-js.github.io/mermaid/#/) to provide client side render diagrams and graphs - sample: http://kcieslak.io/SampleWaypoint/diagrams.html\n\n## How to use template\n\n1. Install `dotnet new` template with `dotnet new -i Waypoint`\n2. Create new folder `mkdir TestApp` and go into it `cd TestApp`\n3. Create new project with `dotnet new Waypoint`\n\n## Motivation\n\nWaypoint got created for couple of reasons. Mostly because I (Chris) was unhappy with possible options \"on the market\" - don't get me wrong, I think projects like MiniScaffold are doing great job, but it was just not hitting my personal sweet spot for what I wanted from project scaffold.\nSecondly I strongly believe into having opinionated set of tools working well together, providing great Developer Experience - building such tools is something I've been doing for last couple of years, so providing single \"package\" seems like a logical next step.\nThirdly, I want Waypoint to be \"canonical\" example of using Fornax for documentation generation - scaffolded template contains really nice theme for documentation, integration with FSharp.Formatting, built-in search support, and more.\n\n\n## Inspired by\n\nNo project lives in vacuum - good ideas are very often just small improvements on the previous state of art. Waypoint has been heavily inspired by:\n\n* [fsprojects/ProjectScaffold](https://github.com/fsprojects/ProjectScaffold) - original F# OSS project template used by countless projects in F# ecosystem\n* [TheAngryByrd/MiniScaffold](https://github.com/TheAngryByrd/MiniScaffold) - great project scaffold created by @TheAngryByrd, having many different options and functionalities\n* [SAFE-Stack/SAFE-template](https://github.com/SAFE-Stack/SAFE-template) - SAFE Stack template by @theimowski\n\n## Used projects\n\n* [.Net Core SDK](https://dotnet.microsoft.com/download) - modern, OSS, cross platform distribution of .Net; `dotnet` - CLI tool for developers\n* [Paket](https://fsprojects.github.io/Paket/) - Paket is a dependency manager for .NET projects, popular in F# community.\n* [FAKE](https://fake.build/) - F# build DSL and task runner\n* [Fornax](https://ionide.io/Tools/fornax.html) - scriptable static site generator using type safe F# DSL to define page layouts\n* [Expecto](https://github.com/haf/expecto) - F# test library\n* [FsCheck](https://github.com/fscheck/FsCheck) - Random testing library for F#\n\n## FAQ\n\n1. What about `fsprojects/ProjectScaffold` ?\n\nProjectScaffold is fairly outdated template, and I think everyone, including original creators of ProjectScaffold will welcome modern alternative.\n\n2. What about `TheAngryByrd/MiniScaffold` ?\n\nMiniScaffold is great project, with many options and functionalities - such as code formatting, test coverage, sourcelinks and more. I've decided to create a scaffold feeding my needs and needs of Ionide projects that's bit more opinionated, and provide less functionalities. Please use whichever scaffold you want!\n\n3. Why do we even need solution scaffold? Is `dotnet new console` and `dotnet build` not enough?\n\nNo, it's not enough. Real world project, unlike conference demos, requires more structure, testing, documentation - especially OSS projects, if you care for adaption and user happiness. Beacuse of that we need something that will provide nice experience for both users and developers of the OSS projects.\n"},{"uri":"/Editors/editoresOverview.html","title":"Editors overview","content":"\n# Editors overview\n\nOne of the main goals of the Ionide initiative is providing rich, cross-platform, open-source IDE for F#."},{"uri":"/Editors/index.html","title":"Index","content":""},{"uri":"/Tools/forge.html","title":"Forge","content":"\n# Forge\n\n**GitHub link:** [https://github.com/ionide/Forge](https://github.com/ionide/Forge)\n**License:** [Unlicense](https://github.com/ionide/Forge/blob/master/LICENSE)\n\nForge is a command line tool that provides tasks for creating and manipulation F# projects. It powers such commands as `Add File Above` or `Move File Down` in Ionide-VSCode solution explorer"},{"uri":"/Tools/fornax.html","title":"Fornax","content":"\n# Fornax\n\n**GitHub link:** [https://github.com/ionide/Fornax](https://github.com/ionide/Fornax)\n**License:** [MIT](https://github.com/ionide/Fornax/blob/master/LICENSE)\n\n\nFornax is a **scriptable static site generator** using type safe F# DSL to define page layouts. This documentation has been built using Fornax.\n\n## Installation\n\nFornax is released as a global .Net Core tool. You can install it with `dotnet tool install fornax -g`\n\n## CLI Application\n\nThe main functionality of Fornax comes from CLI applications that lets user scaffold, and generate webpages.\n\n* `fornax new` - scaffolds new blog in current working directory using really simple template\n* `fornax build` - builds webpage, puts output to `_public` folder\n* `fornax watch` - starts a small webserver that hosts your generated site, and a background process that recompiles the site whenever any changes are detected. This is the recommended way of working with Fornax.\n* `fornax clean` - removes output directory and any temp files\n* `fornax version` - prints out the currently-installed version of Fornax\n* `fornax help` - prints out help\n\n## Getting started\n\nEasiest way to get started with `fornax` is running `fornax new` and than `fornax watch` - this will create fairly minimal blog site template, start `fornax` in watch mode and start webserver. Then you can go to the `localhost:8080` in your browser to see the page, and edit the scaffolded files in editor to make changes.\nAdditionally, you can take a look at `samples` folder in this repository - it have couple more `loaders` and `generators` that you can potentially use in your website.\n\n## Website definition\n\nFornax is using normal F# code (F# script files) to define any of it's core concepts: `loaders`, `generators` and `config`.\n\n### SiteContents\n\n`SiteContents` is fairly simple type that provides access to any information available to the Fornax. The information is put into it by using `loaders` and then can be accessed in the `generators`.\n\n`SiteContents` has several functions in it's public API:\n\n```fsharp\ntype A = {a: string}\ntype B = {b: int; c: int}\n\nlet sc = SiteContents()\nsc.Add({a = \"test\"})\nsc.Add({a = \"test2\"})\nsc.Add({a = \"test3\"})\n\nsc.Add({b = 1; c = 3}) //You can add objects of different types, `Add` method is generic.\n\nlet as = sc.TryGetValues<A>() //This will return option of sequence of all added elements for given type - in this case it will be 3 elements\nlet b = sc.TryGetValue<B>() //This will return option of element for given type\n```\n\n### Loaders\n\n`Loader` is an F# script responsible for loading external data into generation context. The data typically includes things like content of `.md` files, some global site configuration, etc. But since those are normal F# functions, you can do whatever you need.\nWant to load information from local database, or from internet? Sure, why not. Want to use World Bank TP to include some of the World Bank statistics? That's also possible - you can use in `loader` any dependency as in normal F# script.\n\n`Loaders` are normal F# functions that takes as an input `SiteContents` and absolute path to the page root, and returns `SiteContents`:\n\n```fsharp\n#r \"../_lib/Fornax.Core.dll\"\n\ntype Page = {\n    title: string\n    link: string\n}\n\nlet loader (projectRoot: string) (siteContent: SiteContents) =\n    siteContent.Add({title = \"Home\"; link = \"/\"})\n    siteContent.Add({title = \"About\"; link = \"/about.html\"})\n    siteContent.Add({title = \"Contact\"; link = \"/contact.html\"})\n\n    siteContent\n```\n\n**Important note**: You can (and probably should) define multiple loaders - they will all be executed before generation of site, and will propagate information into `SiteContents`\n\n### Generators\n\n`Generator` is an F# script responsible for generating output of the Fornax process. This is usually `.html` file, but can be anything else - actually `generator` API just requires to return `string` that will be saved to file. Generators are, again, plain F# functions that as an input takes `SiteContents`, absolute path to the page root, relative path to the file that's currently processed (may be empty for the global generators) and returns `string`:\n\n```fsharp\n#r \"../_lib/Fornax.Core.dll\"\n#if !FORNAX\n#load \"../loaders/postloader.fsx\"\n#endif\n\nopen Html\n\nlet generate' (ctx : SiteContents) (_: string) =\n    let posts = ctx.TryGetValues<Postloader.Post> () |> Option.defaultValue Seq.empty\n\n    let psts =\n        posts\n        |> Seq.toList\n        |> List.map (fun p -> span [] [!! p.link] )\n\n    html [] [\n        div [] psts\n    ]\n\nlet generate (ctx : SiteContents) (projectRoot: string) (page: string) =\n    generate' ctx page\n    |> HtmlElement.ToString\n```\n\n**Important note**: You can (and probably should) define multiple generators - they will generate different kinds of pages and/or content, such as `post`, `index`, `about`, `rss` etc.\n\n### Configuration\n\n`Configuration` is a F# script file that defines when which analyzers need to be run, and how to save its output. `Config.fsx` file needs to be put in the root of your site project (the place from which you run `fornax` CLI tool)\n\n```fsharp\n#r \"../_lib/Fornax.Core.dll\"\n\nopen Config\nopen System.IO\n\nlet postPredicate (projectRoot: string, page: string) =\n    let fileName = Path.Combine(projectRoot,page)\n    let ext = Path.GetExtension page\n    if ext = \".md\" then\n        let ctn = File.ReadAllText fileName\n        ctn.Contains(\"layout: post\")\n    else\n        false\n\nlet staticPredicate (projectRoot: string, page: string) =\n    let ext = Path.GetExtension page\n    if page.Contains \"_public\" ||\n       page.Contains \"_bin\" ||\n       page.Contains \"_lib\" ||\n       page.Contains \"_data\" ||\n       page.Contains \"_settings\" ||\n       page.Contains \"_config.yml\" ||\n       page.Contains \".sass-cache\" ||\n       page.Contains \".git\" ||\n       page.Contains \".ionide\" ||\n       ext = \".fsx\"\n    then\n        false\n    else\n        true\n\nlet config = {\n    Generators = [\n        {Script = \"less.fsx\"; Trigger = OnFileExt \".less\"; OutputFile = ChangeExtension \"css\" }\n        {Script = \"sass.fsx\"; Trigger = OnFileExt \".scss\"; OutputFile = ChangeExtension \"css\" }\n        {Script = \"post.fsx\"; Trigger = OnFilePredicate postPredicate; OutputFile = ChangeExtension \"html\" }\n        {Script = \"staticfile.fsx\"; Trigger = OnFilePredicate staticPredicate; OutputFile = SameFileName }\n        {Script = \"index.fsx\"; Trigger = Once; OutputFile = NewFileName \"index.html\" }\n\n    ]\n}\n\n```"},{"uri":"/Tools/fsac.html","title":"FsAutoComplete","content":"\n# FsAutoComplete\n\n**GitHub link:** [https://github.com/fsharp/FsAutoComplete](https://github.com/fsharp/FsAutoComplete)\n**License:** [Apache 2.0](https://github.com/fsharp/FsAutoComplete/blob/master/LICENSE)\n\nThe `FsAutoComplete` project (`FSAC`) provides a backend service for rich editing or intellisense features for editors.\nIt can be hosted using the [Language Server Protocol](https://microsoft.github.io/language-server-protocol/).\n\nCurrently it is used by:\n\n* [Emacs](https://github.com/fsharp/emacs-fsharp-mode)\n* [Vim](https://github.com/fsharp/vim-fsharp)\n* [Visual Studio Code](https://github.com/ionide/ionide-vscode-fsharp)\n\nIt's based on:\n\n* [FSharp.Compiler.Service](https://github.com/fsharp/FSharp.Compiler.Service/) for F# language info.\n* [FSharpLint](https://github.com/fsprojects/FSharpLint/) for the linter feature.\n* [Fantomas](https://github.com/fsprojects/fantomas) for the formatting feature.\n* [Dotnet.ProjInfo](Tools/dpi.html) for project/solution management.\n* [FSharp.Analyzers.SDK](/Libraries/fsanalyzers.html) for custom project based analyzers\n\n## Required software\n\nFsAutoComplete can run on .NET/mono or .NET Core. We highly recommend using .Net Core version of FSAC as we plan to remove \"full framework\" version soon - [read more](https://github.com/fsharp/FsAutoComplete/issues/506)\n\n### FSAC .NET Core\n\n* .NET Core Sdk (Required: >= 2.1, Recommended: >= 3.0 )\n\n### FSAC .NET (deprecated)\n\n* on windows: [Microsoft Build Tools 2015](https://www.microsoft.com/en-us/download/details.aspx?id=48159)\n* on unix/mac: Required: Mono >= 5.12, Recommended: Mono >= 5.18\n\n## Communication protocol\n\nFsAutoComplete supports [LSP](https://microsoft.github.io/language-server-protocol/) as a communication protocol.\n\n### Supported LSP endpoints\n\n* `initialize`\n* `textDocument/didOpen`\n* `textDocument/didChange`\n* `textDocument/didSave`\n* `textDocument/hover`\n* `textDocument/completion` & `completionItem/resolve`\n* `textDocument/rename`\n* `textDocument/definition`\n* `textDocument/typeDefinition`\n* `textDocument/implementation`\n* `textDocument/codeAction`:\n  * Remove unused `open`\n  * Resolve namespace/module\n  * Replace unused symbol with `_`\n  * Fix typo based on error message\n  * Remove redundant qualifier\n  * Add missing `new` keyword for `IDisposable`\n  * Generate cases for all DU case in pattern matching\n  * Generate empty interface implementation\n  * Fixes suggested by [FSharpLint](https://github.com/fsprojects/FSharpLint)\n* `textDocument/codeLens` & `codeLens/resolve`:\n  * signature Code Lenses\n  * reference number Code Lenses\n* `textDocument/formatting` - powered by [fantomas](https://github.com/fsprojects/fantomas)\n* `textDocument/references`\n* `textDocument/documentHighlight`\n* `textDocument/signatureHelp`\n* `textDocument/documentSymbol`\n* `workspace/didChangeWatchedFiles`\n* `workspace/didChangeConfiguration`\n* `workspace/symbol`\n\n### Custom endpoints\n\nCustom endpoints are using (for messages body) `PlainNotification` type and string format serialized with exactly same serialization format as old JSON protocol\n\n* `fsharp/signature` - accepts `TextDocumentPositionParams`, returns signature of symbol at given position as a formatted string\n* `fsharp/signatureData` - accepts `TextDocumentPositionParams`, returns signature of symbol at given position as DTO\n* `fsharp/lineLens` - accepts `ProjectParms` (`Project` filed contain F# file path), returns locations where LineLenses should be displayed\n* `fsharp/compilerLocation` - no input, returns paths to FCS, FSI and MsBuild\n* `fsharp/compile` - accepts `ProjectParms`, tries to compile project, returns list of errors and exit status code\n* `fsharp/workspacePeek` - accepts `WorkspacePeekRequest`, returns list of possible workspaces (resolved solution files, or list of projects if there are no solution files)\n* `fsharp/workspaceLoad` - accepts `WorkspaceLoadParms`, loads given list of projects in the background, partial result notified by `fsharp/notifyWorkspace` notification\n* `fsharp/project` - accepts `ProjectParms`, loads given project\n* `fsharp/fsdn` - accepts `ProjectParms` (`Project` filed contain query string), query FSDN and returns list of functions\n* `fsharp/f1Help` - accepts `TextDocumentPositionParams`, returns URL to MSDN documentation for symbol at given position\n* `fsharp/documentation` - accepts `TextDocumentPositionParams`, returns documentation data about symbol at given position, used for InfoPanel\n* `fsharp/documentationSymbol` - accepts `DocumentationForSymbolReuqest`, returns documentation data about given symbol from given assembly, used for InfoPanel\n\n### Supported LSP notifications\n\n* `window/showMessage`\n* `window/logMessage`\n* `textDocument/publishDiagnostics`\n\n### Custom notifications\n\n* `fsharp/notifyWorkspace` - notification for workspace/solution/project loading events\n* `fsharp/notifyWorkspacePeek` - notification for initial workspace peek\n\n### Additional startup options\n\n* `--background-service-enabled` - passing this flag enables background service feature, increasing FSAC responsiveness by moving some of the operations (especially background type checking) to other process. It results in increased memory usage. Used by default in Ionide.\n* `--verbose` - passing this flag enables additional logging being printed out in `stderr`\n* `DOTNET_ROOT` - setting this environment variable will set the dotnet SDK root, which is used when finding references for FSX scripts.\n\n### Initialization options\n\nOptions that should be send as `initializationOptions` as part of `initialize` request.\n\n* `AutomaticWorkspaceInit` - setting it to `true` will start Workspace Loading without need to run `fsharp/workspacePeek` and `fsharp/workspaceLoad` commands. It will always choose top workspace from the found list - all projects in workspace if 0 `.sln` files are found, `.sln` file if 1 `.sln` file was found, `.sln` file with most projects if multiple `.sln` files were found. It's designed to be used in clients that doesn't allow to create custom UI for selecting workspaces.\n\n### Settings\n\n* `FSharp.keywordsAutocomplete` - provides keywords in autocomplete list, recommended default value: `true`\n* `FSharp.ExternalAutocomplete` - provides autocomplete for symbols from not opened namespaces/modules, insert `open` on accept, recommended default value: `false`\n* `FSharp.Linter` - enables FSharpLint integration, provides additional warnings and code action fixes, recommended default value: `true`\n* `FSharp.UnionCaseStubGeneration` - enables code action to generate pattern matching cases, recommended default value: `true`\n* `FSharp.UnionCaseStubGenerationBody` - defines dummy body used by pattern matching generator, recommended default value: `\"failwith \\\"Not Implemented\\\"\"`\n* `FSharp.RecordStubGeneration` - enables code action to generate record stub, recommended default value: `true`\n* `FSharp.RecordStubGenerationBody` - defines dummy body used by record stub generator, recommended default value: `\"failwith \\\"Not Implemented\\\"\"`\n* `FSharp.InterfaceStubGeneration` - enables code action to generate interface stub, recommended default value: `true`\n* `FSharp.InterfaceStubGenerationObjectIdentifier` - defines object identifier used by interface stub generator,recommended default value: `\"this\"`\n* `FSharp.InterfaceStubGenerationMethodBody` - defines dummy body used by interface stub generator, recommended default value: `\"failwith \\\"Not Implemented\\\"\"`\n* `FSharp.UnusedOpensAnalyzer` - enables unused `open` detections, recommended default value: `true`\n* `FSharp.UnusedDeclarationsAnalyzer` - enables unused symbol detection, recommended default value: `true`\n* `FSharp.UseSdkScripts` - enables the use of .Net Core SDKs for script file type-checking and evaluation, otherwise the .Net Framework reference lists will be used. Recommended default value: `true`. Current default value: `false`\n* `FSharp.SimplifyNameAnalyzer` - enables simplify name analyzer and remove redundant qualifier quick fix, recommended default value: `false`\n* `FSharp.ResolveNamespaces` - enables resolve namespace quick fix (add `open` if symbol is from not yet opened module/namespace), recommended default value: `true`\n* `FSharp.EnableReferenceCodeLens` - enables reference count code lenses, recommended default value: `true` if `--background-service-enabled` is used by default, `false` otherwise\n* `FSharp.dotNetRoot` - sets the root path for finding dotnet SDK references. Primarily used for FSX Scripts. Default value: operating-system dependent. On windows, `C:\\Program Files\\dotnet`; on Unix, `/usr/local/share/dotnet`\n* `FSharp.fsiExtraParameters` - an array of additional runtime arguments that are passed to FSI. These are used when typechecking scripts to ensure that typechecking has the same context as your FSI instances.  An example would be to set the following parameters to enable Preview features (like opening static classes) for typechecking."},{"uri":"/Tools/dpi.html","title":"dotnet-proj-info","content":"\n# dotnet-proj-info\n\n**GitHub link:** [https://github.com/ionide/dotnet-proj-info](https://github.com/ionide/dotnet-proj-info)\n**License:** [MIT](https://github.com/ionide/dotnet-proj-info/blob/master/LICENSE)\n\n`dotnet-proj-info` is library and command line tool used to parse and evaluate MsBuild files (`.fsproj`). It's used to get out of project files properties, list of files, list of project references, list of .Net references and more. It supports projects targeting both .Net Framework and .Net Core, using either old (verbose) project format or new (SDK-based) one. It's powering project cracking in [FsAutoComplete](/Tools/fsac.html) and solution explorer in [Ionide-VSCode](/Editors/vscode.html)\n\n### How to use\n\nInstall with:\n\n```bash\ndotnet tool install -g dotnet-proj\n```\n\nand\n\n```bash\ndotnet proj --help\n```\n\nUsage:\n\n```\ndotnet-proj.\n\nUSAGE: dotnet-proj [--help] [--verbose] [<subcommand> [<options>]]\n\nSUBCOMMANDS:\n\n    prop <options>        get properties\n    fsc-args <options>    get fsc arguments\n    csc-args <options>    get csc arguments\n    p2p <options>         get project references\n    net-fw <options>      list the installed .NET Frameworks\n    net-fw-ref <options>  get the reference path of given .NET Framework assembly\n\n    Use 'dotnet-proj <subcommand> --help' for additional information.\n\nOPTIONS:\n\n    --verbose, -v         verbose log\n    --help                display this list of options.\n```\n\nSubcommands support usual arguments of .NET cli (`dotnet`) where it makes sense, for example:\n\n- the target project\n- `-c` or `--configuration`\n- `-f` or `--framework`\n- `-r` or `--runtime`"},{"uri":"/Editors/Code/options.html","title":"List of options","content":"\n# List of options\n\n## How to set an option?\n\nIt is easy to configure Visual Studio Code to your liking through its various settings. Nearly every part of VS Code's editor, user interface, and functional behavior has options you can modify.\n\nVS Code provides two different scopes for settings:\n\n* **User Settings** - Settings that apply globally to any instance of VS Code you open.\n* **Workspace Settings** - Settings stored inside your workspace and only apply when the workspace is opened.\n\nWorkspace settings override user settings. Workspace settings are specific to a project and can be shared across developers on a project.\n\n> Note: A VS Code \"workspace\" is usually just your project root folder\n\nTo open your user and workspace settings, use the following VS Code menu command:\n\n* On Windows/Linux - `File > Preferences > Settings`\n* On macOS - `Code > Preferences > Settings`\n\nYou can also open the Settings editor from the Command Palette (`Ctrl+Shift+P`) with `Preferences: Open Settings` or use the keyboard shortcut (`Ctrl+,`).\n\nRead more about settings in VSCode in [VSCode documentation](https://code.visualstudio.com/docs/getstarted/settings)\n\n---\n\n#### `FSharp.fsac.netCoreDllPath`\n\nThe path to the `fsautocomplete.dll`, useful for debugging a self-built fsac.\n\n**Type:** `string`\n\n**Default:** ` `\n\n---\n\n#### `FSharp.fsac.netExePath`\n\nThe path to the `fsautocomplete.exe`, useful for debugging a self-built fsac.\n\n**Type:** `string`\n\n**Default:** ` `\n\n---\n\n#### `FSharp.fsac.attachDebugger`\n\nAppends the '--attachdebugger' argument to fsac, this will allow you to attach the debugger.\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.fsacRuntime`\n\nChoose the runtime of FsAutocomplete (FSAC). Requires restart.\n\n**Type:** `enum`\n\n**Possible values:**\n * `net`\n * `netcore`\n\n**Default:** `netcore`\n\n---\n\n#### `FSharp.workspaceModePeekDeepLevel`\n\nThe deep level of directory hierarchy when searching for sln/projects\n\n**Type:** `int`\n\n**Default:** `4`\n\n---\n\n#### `FSharp.monoPath`\n\nThe path to Mono executable\n\n**Type:** `string`\n\n**Default:** `mono`\n\n---\n\n#### `FSharp.fsiFilePath`\n\nThe path to the F# Interactive tool used by Ionide-FSharp\n\n**Type:** `string`\n\n**Default:** ` `\n\n---\n\n#### `FSharp.keywordsAutocomplete`\n\nIncludes keywords in autocomplete\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.externalAutocomplete`\n\nIncludes external (from unopen modules and namespaces) symbols in autocomplete\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.linter`\n\nEnables integration with FSharpLinter (additional warnings)\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.unionCaseStubGeneration`\n\nEnables pattern matching stub generation\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.unionCaseStubGenerationBody`\n\nGenerated pattern matching case default body\n\n**Type:** `string`\n\n**Default:** `failwith \\\"Not Implemented\\\"`\n\n---\n\n#### `FSharp.recordStubGeneration`\n\nEnables record stub generation\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.recordStubGenerationBody`\n\nGenerated record field default body\n\n**Type:** `string`\n\n**Default:** `failwith \\\"Not Implemented\\\"`\n\n---\n\n#### `FSharp.interfaceStubGeneration`\n\nEnables interface stub generation\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.interfaceStubGenerationMethodBody`\n\nGenerated member default body\n\n**Type:** `string`\n\n**Default:** `failwith \\\"Not Implemented\\\"`\n\n---\n\n#### `FSharp.interfaceStubGenerationObjectIdentifier`\n\nGenerated member default object identifier\n\n**Type:** `string`\n\n**Default:** `this`\n\n---\n\n#### `FSharp.unusedOpensAnalyzer`\n\nEnables detection of unused opens\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.unusedDeclarationsAnalyzer`\n\nEnables detection of unused declarations\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.simplifyNameAnalyzer`\n\nEnables detection of symbols usages that can be simplified\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.fsiExtraParameters`\n\nAllows to pass extra parameters to FSI process\n\n**Type:** `array`\n\n**Default:** `[]`\n\n---\n\n#### `FSharp.saveOnSendLastSelection`\n\nSave Current file before send LastSelection to FSI\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.msbuildLocation`\n\nUse a specific version of msbuild to build this project.\n\n**Type:** `string`\n\n**Default:** ` `\n\n---\n\n#### `FSharp.msbuildAutoshow`\n\nAutomatically shows MsBuild output panel\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.msbuildHost`\n\nMSBuild host\n\n**Type:** `enum`\n\n**Possible values:**\n * `.net`\n * `.net core`\n * `ask at first use`\n * `auto`\n\n**Default:** `auto`\n\n---\n\n#### `FSharp.resolveNamespaces`\n\nEnables `resolve unopened namespaces and modules` code fix.\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.enableTreeView`\n\nEnables solution explorer.\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.excludeProjectDirectories`\n\nDirectories in the array are excluded from project file search. Requires restart.\n\n**Type:** `array`\n\n**Default:** `[\".git\",\"paket-files\",\".fable\",\"packages\",\"node_modules\"]`\n\n---\n\n#### `FSharp.lineLens.enabled`\n\nUsage mode for LineLens\n\n**Type:** `enum`\n\n**Possible values:**\n * `never`\n * `replaceCodeLens`\n * `always`\n\n**Default:** `replaceCodeLens`\n\n---\n\n#### `FSharp.lineLens.prefix`\n\nThe prefix displayed before the signature\n\n**Type:** `string`\n\n**Default:** `//`\n\n---\n\n#### `FSharp.disableFailedProjectNotifications`\n\nDisables popup notifications for failed project loading\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.enableBackgroundServices`\n\nEnables background services responsible for creating symbol cache and typechecking files in the background. Requires restart.\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.enableReferenceCodeLens`\n\nEnables additional code lenses showing number of references. Requires background services\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.showProjectExplorerIn`\n\nSet the activity (left bar) where the project explorer view will be displayed.Requires restart.\n\n**Type:** `enum`\n\n**Possible values:**\n * `explorer`\n * `fsharp`\n\n**Default:** `fsharp`\n\n---\n\n#### `FSharp.enableAnalyzers`\n\nEXPERIMENTAL. Enables custom analyzers. Requires restart.\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.analyzersPath`\n\nDirectories in the array are used as a source of custom analyzers. Requires restart.\n\n**Type:** `array`\n\n**Default:** `[\"packages/Analyzers\", \"analyzers\"]`\n\n---\n\n#### `FSharp.workspacePath`\n\nPath to the directory or solution file that should be loaded as a workspace\n\n**Type:** `string`\n\n---\n\n#### `FSharp.showExplorerOnStartup`\n\nAutomatically shows solution explorer on plugin startup\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.enableTouchBar`\n\nEnables TouchBar integration\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.autoRevealInExplorer`\n\nSet the activity (left bar) where the project explorer view will be displayed.Requires restart.\n\n**Type:** `enum`\n\n**Possible values:**\n * `sameAsFileExplorer`\n * `enabled`\n * `disabled`\n\n**Default:** `sameAsFileExplorer`\n\n---\n\n#### `FSharp.smartIndent`\n\nEnables smart indent feature\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.infoPanelUpdate`\n\nControls when the info panel is updated\n\n**Type:** `enum`\n\n**Possible values:**\n * `onCursorMove`\n * `onHover`\n * `both`\n * `none`\n\n**Default:** `onCursorMove`\n\n---\n\n#### `FSharp.infoPanelReplaceHover`\n\nControls whether the info panel replaces tooltips\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.infoPanelStartLocked`\n\nControls whether the info panel should be locked at startup\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.infoPanelShowOnStartup`\n\nControls whether the info panel should be displayed at startup\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.verboseLogging`\n\nLogs additional information to F# output channel. Requires restart.\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FAKE.targetsOutline`\n\nEnables the Targets Outline tree view.\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FAKE.showTargetsOutlineIn`\n\nSet the activity (left bar) where the FAKE targets outline view will be displayed.Requires restart.\n\n**Type:** `enum`\n\n**Possible values:**\n * `explorer`\n * `fsharp`\n\n**Default:** `explorer`\n\n---\n\n#### `FSharp.suggestGitignore`\n\nAllow Ionide to prompt whenever internal data files aren't included in your project's .gitignore\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.useSdkScripts`\n\nUse `dotnet fsi` instead of `fsi.exe`/`fsharpi`\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.dotNetRoot`\n\nSets the root path for finding dotnet SDK references. Primarily used for FSX Scripts.\n\n**Type:** `string`\n\n---"},{"uri":"/Editors/Code/getting_started.html","title":"Getting started","content":"\n# Getting started\n\n## Requirements\n\n* Visual Studio Code - it is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux created by Microsoft. For detailed documentation of editor, getting-started guides and more visit [official documentation](https://code.visualstudio.com/docs).\n\n* F# - it is a mature, open source, cross-platform, functional-first programming language. It empowers users and organizations to tackle complex computing problems with simple, maintainable and robust code. Ionide supports any version of F# >= 3.0 but we do recommend using F# 4.1. Detailed installation instructions can be found of F# Software foundation webpage - for [Windows](http://fsharp.org/use/windows/), [MacOS](http://fsharp.org/use/mac/), and [Linux](http://fsharp.org/use/linux/)\n\n* .Net Core SDK - .Net Core is lightweight, cross platform, modern implementation of .Net Framework. We strongly recommend installing it since some advanced Ionide features such as debugging and project scaffolding depends on SDK and `dotnet` CLI tooling even if your application is targetting Full Framework. For detailed instructions on installing .Net Core visit [official step-by-step installation guide](https://www.microsoft.com/net/core)\n\n* VSCode C# plugin (optional) - Ionide's debugging capabilities relies on the debugger provided by Omnisharp team. To get it install [C# extension from VSCode marketplace](https://marketplace.visualstudio.com/items?itemName=ms-vscode.csharp)\n\n* MsBuild 2015 (Windows only, optional) - For old, verbose `.fsproj` files on Windows MsBuild 2015 (14.0) needs to be additionally installed. You can download it [here](https://www.microsoft.com/en-us/download/details.aspx?id=48159). However, we highly recommend using new, SDK-based project files.\n\n## Plugin installation\n\nAny VSCode extension can be installed using UI just inside VSCode. Bring up the Extensions view by clicking on the Extensions icon in the Activity Bar on the side of VS Code or the `View: Extensions` command (`Ctrl+Shift+X`). Then in search box type `Ionide` to find all 3 extensions we provide. Click the `Install` button and after a successful install, you'll see an `Reload` button which will prompt you to restart VS Code to enable the new extension. For more detailed information about plugin installation visit [VSCode documentation](https://code.visualstudio.com/docs/editor/extension-gallery)\n\n## Plugin activation\n\nVSCode plugins are running in external processes (which means they should never impact editor performance) and are activated lazily, when certain activation events happens. This means that plugins are not loaded unnecesserly, for example when you don't work on project using given programming language.\n\nIonide plugins are activated when:\n\n* Opened workspace contains any `.fsproj`, `.fs`, or `.fsx` file\n\n* New `.fsproj`, `.fs`, or `.fsx` file is created in workspace that was not containing those files before.\n"},{"uri":"/Editors/Code/overview.html","title":"Overview","content":"\n# Ionide-VSCode\n\n**GitHub link:** [https://github.com/ionide/Ionide-vscode-fsharp](https://github.com/ionide/Ionide-vscode-fsharp)\n**License:** [MIT](https://github.com/ionide/Ionide-vscode-fsharp/blob/master/LICENSE.md)\n\nIonide is a [Visual Studio Code](https://code.visualstudio.com/) package suite for cross platform F# development.\n\n<img class=\"gif\" src=\"/static/images/fsharp.gif\" />\n\n## Overview\n\nIonide for VSCode is set of 3 plugins avaliable in VSCode marketplace.\n\n* [Ionide-fsharp](https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-fsharp) - provides F# specific features including advanced editor features (autocomplete, go-to definition, tooltips, rename, various refactorings and quick fix suggestions), integration with .Net project system, project explorer for project file visualization and manipulation, integration with MsBuild for building and running applications, debugger integration and more.\n\n<img class=\"gif\" src=\"/static/images/fsi.gif\" />\n\n\n* [Ionide-Paket](https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-Paket) - provides integration with Paket - package dependency manager for .NET with support for NuGet packages and GitHub repositories.\n\n<img class=\"gif\" src=\"/static/images/paket.gif\" />\n\n* [Ionide-FAKE](https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-fake) - FAKE (F# Make) is popular F# tool and DSL for build orchestration.\n\n<img class=\"gif\" src=\"/static/images/fake.gif\" />\n\n## List of features\n\n#### F# IDE\n\n* Syntax highlighting\n* Error highlighting\n* Autocomplete\n* Tooltips\n* Quick Info Toolbar\n* Usages highlighting\n* F# Interactive (REPL) panel\n* Go-to declaration\n* Finding symbols in file\n* Go-to any symbol in solution\n* Rename\n* Find usages\n* Peek View declaration\n* CodeLens feature showing type signatures\n* CodeOutline tree view\n* Listing all errors in workspace\n* Building using msbuild / xbuild\n* Integration with .Net Core\n* Project explorer tree view\n* Debugging\n* Record stub generation\n* Union pattern case generation\n* Integration with F# Interactive\n\n#### F# Project management\n\n* Integration with [Forge](/Tools/forge.html)\n* Possibility to create new empty solutions or projects (multiple templates for most popular project types)\n* Adding, removing, ordering files in project\n* Adding and removing project references\n\n#### Paket integration\n\n* Paket initialization\n* Adding, installing, updating packages from solution or current project (allows the choice of package version)\n* Removing packages from solution or current project\n* Converting from NuGet, simplify dependency graph, turning on auto-restore for solution.\n* Listing outdated packages\n\n#### FAKE integration\n\n* Running any build target defined in FAKE build script\n* Running default FAKE target\n\n#### MSBuild/XBuild integration\n\n* Build/Clean/Rebuild the current project\n* Build/Clean/Rebuild any project in the current workspace\n* Works with the most recent version of msbuild/xsbuild on your system, or supply your own\n\n#### And much more...\n\n"},{"uri":"/Editors/Code/generalInfo.html","title":"General information","content":"\n# General information\n\nIonide is complex tool with many options, and powerful capabilities, supporting multiple scenarios available to F# developers. As such is crucial to learn some general information about Ionide's requirements, and different configuration options that should be used depending on the different runtime and environments that can be used.\n\n### Getting Requirements\n\n* F# (Windows) - Easiest way to install latest versions of F# on Windows is using [VS Build Tools 2017](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=button+cta&utm_content=download+vs2017#build-tools-for-visual-studio-2017). If you use VS 2017, make sure that you've installed workload adding F# support.\n\n* F# (Linux/MacOS) - F# on non-Windows platform is distributed as part of the `mono`. Installation guide and recent version of `mono` can be found on the [project webpage](https://www.mono-project.com/download/stable/) and on the F# Software Foundation [\"Use on Linux\" page](https://fsharp.org/use/linux/)\n\n* .Net Core SDK - .Net Core is modern, cross platform implementation of .Net Framework. Ionide is requiring it for set of features such as project modifications or debugging. The core part of SDK is `dotnet` CLI tool that provides easy way to create, build and run F# projects. What's important - the `dotnet` tool can be used also to create applications targeting also Full Framewok (like `net461`). For detailed instructions on installing .Net Core visit [official step-by-step installation guide](https://www.microsoft.com/net/core)\n\n* VSCode C# plugin (optional) - Ionide's debugging capabilities relies on the debugger provided by Omnisharp team. To get it install [C# extension from VSCode marketplace](https://marketplace.visualstudio.com/items?itemName=ms-vscode.csharp)\n\n* MsBuild 2015 (Windows only, optional) - For old, verbose `.fsproj` files on Windows MsBuild 2015 (14.0) needs to be additionally installed. You can download it [here](https://www.microsoft.com/en-us/download/details.aspx?id=48159). However, we highly recommend using new, SDK-based project files.\n\n### Project files parsing\n\nIonide supports both old, verbose project files, and new SDK based files. However, we **strongly recommend** using SDK based project files. Plugin is also supporting parsing `.sln` files. When you open VSCode in particular workspace, Ionide will try to find all `.sln` files in this workspace and you will be presented with the option to open particular solution, or ignore solution files and load all projects in the solution.\n\n<img class=\"gif\" src=\"/static/images/chooseSolution.png\" />\n\n\nWhen Ionide detects any F# projects it will display them in the `Solution Explorer`. To access it you need to press F# logo button on the activity bar. In there you will see list of F# projects, their status, list of file and references. You can also right-click on different nodes in the tree to access operations that can be performed by the Ionide, such as `Build Project` or `Add file`.\n\n<img class=\"gif\" src=\"/static/images/projectExplorer.png\" />\n\n> NOTE: In case of the problems with project parsing (Projects in status `loading failed`) you can right-click on the project node and use `Show Project Status` to see more details about the problem. We also recommend using `F#: Clear Cache` action and reloading the window, as first step in debugging any problems.\n\n### FsAutoComplete Service Runtime\n\nThe Ionide plugin relies on the F# compiler services for processing code in the editor.  The compiler services can run under the full framework (requiring `mono` on non-Windows platforms) or they can run under .NET Core as of Ionide 3.13.0.  This experimental feature can be enabled in the user settings.\n\n`Preferences > Settings` and add a new setting\n```json\n\"FSharp.fsacRuntime\": \"netcore\"\n```\n\nThere are two options:\n\n* `netcore` (default) .NET Core framework\n* `net`  full framework\n\nAfter updating this setting, execute the `Reload Window` command in VS Code for the setting to take effect.\n\n> NOTE: projects that use functionality incompatible with .NET Core, such as type providers, require this be set to `net` in order for the F# Autocomplete Service to process code using these features.\n\n### MsBuild Host\n\nThe Ionide plugin provides deep integration with MsBuild - starting from project parsing (process of getting list of files, references and properties out of `fsproj` file) through project modifications (adding new files, ordering them, adding project-to-project references) to building and running projects. All features provided by Ionide in area of project management are described more in [Project](project) section.\n\nIonide can use either MsBuild installation provided by Full Framework (installed by VS / VS Build Tools on Windows and by Mono on Linux/MacOS) or the cross platform version of MsBuild provided by .Net Core SDK. In most cases Ionide makes automatic decision which one to use based on the type of project file, but projects that use functionality incompatible with .NET Core, such as type providers not updated to latest TP SDK, require using Full Framework installation of MsBuild.\n\nTo control MsBuild Host that's used by Ionide you need to go to the F# Solution Explorer view and use `F#: Pick MsBuild Host` action\n\n<img class=\"gif\" src=\"/static/images/pickMsBuildHost.png\" />"},{"uri":"/Editors/Code/editing.html","title":"Editing evolved","content":"# Editing evolved\n\nIonide provides variety of language features known from more IDEs such as VS, and set of innovative features that makes you more productive then ever when writing F# code like CodeLenses, integration with FSharpLint and Quick Fixes.\n\n## Basic features\n\nFollowing documentation is basic overview of features from Ionide's point of view. If you want to learn more about capabilities of VSCode visit [official documentation](https://code.visualstudio.com/docs/editor/codebasics). We strongly recommend exploring detailed VSCode documentation, especially if you've never worked with similar (Atom, ST3) editor before.\n\n### IntelliSense\n\nIf Ionide knows possible completions, the IntelliSense suggestions will pop up as you type. If you continue typing characters, the list of members (variables, methods, etc.) is filtered to include only members containing your typed characters. Pressing `Tab` or `Enter` will insert the selected member.\n\nYou can trigger IntelliSense in any editor window by typing `Ctrl+Space` or by typing a trigger character (such as the dot character (`.`)).\n\n> Tip: The suggestions widget supports CamelCase filtering meaning you can type the letters which are upper cased in a method name to limit the suggestions. For example, \"cra\" will quickly bring up \"createApplication\".\n\nAdditionally, Ionide provides autocompletion for symbols not defined in currently opened modules and namespaces. If you accept such completion with `Tab` or `Enter` it will automatically insert appropriate `open` statement. This behavior is controlled by `FSharp.externalAutocomplete` setting (default value is `true`).\n\n---\n\nAdditionally, you can see quick info for each method by either pressing `Ctrl+Space` or clicking the info icon. The accompanying documentation for the method will now expand to the side. The expanded documentation will stay so and will update as you navigate the list. You can close this by pressing `Ctrl+Space` again or by clicking on the close icon.\n\n<img class=\"gif\" src=\"/static/images/autocomplete.gif\" />\n\n### Tooltips\n\nIonide provides rich information about the symbols you hover on - structured signature and nicely formatted documentation text supporting markdown inside of the comments and transforming standard XML comment tags into markdown representation.\n\n> Tip: If you press `Ctrl` while hovering Ionide will also put the body of the symbol in the tooltip.\n\n<img class=\"gif\" src=\"/static/images/tooltips.gif\" />\n\n\n### Error highlighting\n\nIonide provides fast error highlighting for local changes, changes in current project and cross project changes without any need to build projects. Error highlighting for current projects works as you edit code, it supports files not saved to disk. For cross project error reporting you need to save the file - it will queue background project type checking which will provide errors asynchronously without blocking any editor operations.\n\nErrors in VSCode are shown in multiple places:\n* In the status bar, there is a summary of all errors and warnings counts.\n* You can click on the summary or press `Ctrl+Shift+M` to display the `PROBLEMS` panel with a list of all current errors.\n* If you open a file that has errors or warnings, they will be rendered inline with the text and in the overview ruler.\n\n> Tip: To loop through errors or warnings in the current file, you can press `F8` or `Shift+F8` which will show an inline zone detailing the problem and possible code actions (if available).\n\n<img class=\"gif\" src=\"/static/images/errors.gif\" />\n\n\n### CodeLens and LineLens\n\nIonide displays type signatures of the symbols either as information over the symbol (inserting virtual line) or as inlined information next to symbol. The behavior is customizable with `editor.codeLens`, `FSharp.lineLens.enabled` and `FSharp.lineLens.*` settings.\n\n### Quick Info panel\n\nYou can check the type of symbol on which cursor currently is in the left part of VSCode Status Bar (bottom bar with different additional information about current position and file)\n\n### Generate record stubs\n\nYou can generate record stubs by using the `Quick Fix` feature (Default keyboard shortcut is `Ctrl+.`). The feature is activated in two ways:\n\n* Using a type hint ```let p : Person = { }``` with the cursor over `Person`\n* Starting to type the fields of the record\n\n<img class=\"gif\" src=\"/static/images/generateRecordStubs.gif\" />\n\n### Generate pattern matching stubs\n\nYou can generate pattern matching stubs by using the `Quick Fix` feature (Default keyboard shortcut is `Ctrl+.`).\n\n### Generate object expression implementation stub\n\nYou can generate object expression implementation stub by using the `Quick Fix` feature (Default keyboard shortcut is `Ctrl+.`).\n\n## Code navigation\n\nVisual Studio Code has a high productivity code editor which, when combined with programming language services, gives you the power of an IDE and the speed of a text editor. In this part we will show different ways of navigating around the code.\n\n### Go to definition\n\nIonide provides going to symbol definition. You can do that by pressing `F12`, pressing right click on symbol and choosing `Go to definition` or by using `Ctrl+Click` or running `Go to definition` from Command Palette.\n\n> Tip: You can use `Ctrl+Alt+Click` or open the definition to the side in additional editor panel.\n\n### Go to type definition\n\nIonide provides going to definition of the type of current symbol if the type was defined in local workspace. You can do that by running the `Go to Type Definition` command from either the editor context menu or the Command Palette.\n\n> Tip: The command `editor.action.goToTypeDefinition` is not bound to a keyboard shortcut by default but you can add your own custom keybinding.\n\n### Go to symbol in file\n\nYou can navigate symbols inside a file with `Ctrl+Shift+O`. Just press `Up` or `Down` and navigate to the place you want.\n\n> Tip: By typing `:` the symbols will be grouped by category.\n\n### Go to symbol in workspace\n\nIonide support jumping to a symbol across files with `Ctrl+T`. Just type the first letter of a symbol you want to navigate to, regardless of which file contains it, and press `Enter`.\n\n<img class=\"gif\" src=\"/static/images/goToSymbol.gif\" />\n\n### Find all references & Peek definition\n\nIonide also implements providers for finding all references (`Shift+F12`) of the symbol in currently open solution and peeking definition of the symbol (`Alt+F12`). VSCode provides peeked editors which enables you to see the source code of the other file inlined without switching context. You can navigate between different references in the peeked editor and make quick edits right there. Clicking on the peeked editor filename or double-clicking in the result list will open the reference in the outer editor.\n\n<img class=\"gif\" src=\"/static/images/peek.gif\" />\n\n### Bracket matching\n\nMatching brackets will be highlighted as soon as the cursor is near one of them.\n\n> Tip: You can jump to the matching bracket with `Ctrl+Shift+\\`\n\n### Go to next symbol usage\n\nUsages of symbol in current file will be highlighted as soon as the cursor is on the symbol.\n\n> Tip: You can jump to the next/previous usage with `F7` and `Shift+F7`\n\n### Go to MSDN help\n\nIonide provides command for opening MSDN documentation for given symbol. It works only for symbols from F# standard library, and .Net standard library. You can execute command with `Shift+F1` or from Command Palette (`F#: Get Help`).\n\n### CodeOutline panel\n\nIonide provides live updated panel showing symbols in current file. It's available as a additional tree view (`F# Code Outline`) in VSCode Explorer panel. On the panel you can notice 2 buttons - right one collapse (`Click`) or extends (`Alt+Click`) all elements in the tree, left one refreshes default collapsing (only modules and namespaces extended, types collapsed).\n\n> Tip: Clicking on any node in the tree will move you to the place in file where symbol is defined. It's really useful for navigating around huge files.\n\n<img class=\"gif\" src=\"/static/images/codeOutline.gif\" />\n\n## Advanced analyzers\n\n### FSharpLint integration\n\n### Unused value analyzer\n\n### Unnecessary open statement analyzer\n\n### Simplify name analyzer\n\n## Refactoring\n\n### Rename symbol\n\n### Quick fixes\n\n### Generate comment scaffold\n"},{"uri":"/Editors/Vim/usage.html","title":"How to use","content":"\n# How to use\n\nOpening either `*.fs`, `*.fsi` or `*.fsx` files should trigger syntax highlighting and other depending runtime files as well.\n\n### Commands\n\nRefer to [LanguageClient-neovim](https://github.com/autozimu/LanguageClient-neovim) for features provided via Language Server Protocol.\n\nTo be added as requested for F#-specific features.\n\n#### `:FSharpLoadWorkspaceAuto`\n  - Searches a workspace (`sln` or `fsproj`) and then load it.\n  - Equivalent to `FSharp.workspaceMode = sln` in Ionide-VSCode.\n  - Automatically called when you open F# files. Can be disabled in settings.\n  - The deep level of directory hierarchy to search can also be configured in settings.\n\n#### `:FSharpParseProject <files>+`\n  - Loads specified projects (`sln` or `fsproj`).\n\n#### `:FSharpReloadWorkspace`\n  - Reloads all the projects currently loaded.\n  - Automatically called when you save `.fsproj` files. Can be disabled in settings.\n\n#### `:FSharpUpdateServerConfig`\n  - Updates FSAC configuration.\n  - See [FsAutoComplete Settings](#fsautocomplete-settings) for details.\n\n#### `:FSharpUpdateFSAC`\n  - Downloads the latest build of FsAutoComplete to be used with Ionide-vim.\n\n### Working with F# Interactive\n\nIonide-vim has an integration with F# Interactive.\n\nFSI is displayed using the builtin `:terminal` feature introduced in Vim 8 / Neovim and can be used like in VSCode.\n\n#### `:FsiShow`\n  - Shows a F# Interactive window.\n\n#### `:FsiEval <expr>`\n  - Evaluates given expression in FSI.\n\n#### `:FsiEvalBuffer`\n  - Sends the content of current file to FSI.\n\n#### `:FsiReset`\n  - Resets the current FSI session.\n\n#### `Alt-Enter`\n  - When in normal mode, sends the current line to FSI.\n  - When in visual mode, sends the selection to FSI.\n  - Sending code to FSI opens FSI window but the cursor does not focus to it. Unlike Neovim, Vim doesn't support asynchronous buffer updating so you have to input something (e.g. moving cursor) to see the result. You can change this behavior in settings.\n\n#### `Alt-@`\n  - Toggles FSI window. FSI windows shown in different tabpages share the same FSI session.\n  - When opened, the cursor automatically focuses to the FSI window (unlike in `Alt-Enter` by default).\n\nYou can customize the location of FSI, key mappings, etc. See [the documentation below](#f-interactive-settings).\n\n### Settings\n\nRefer to [LanguageClient-neovim's recommended settings](https://github.com/autozimu/LanguageClient-neovim/wiki/Recommended-Settings#recommended-settings)\nfor features provided via Language Server Protocol.\n\nTo be added as requested for F#-specific features.\n\n#### FsAutoComplete Settings\n\n* Ionide-vim uses `snake_case` for the setting names.\n  - For FSAC settings only, `CamelCase` can also be used (as it gets serialized to a F# record).\n  - If both `snake_case` and `CamelCase` are specified, the `snake_case` one will be preferred.\n* You can change the values at runtime and then notify the changes to FSAC by `:FSharpUpdateServerConfig`.\n* Some of the settings may not work in Ionide-vim as it is lacking the corresponding feature of Ionide-VSCode.\n* If not specified, the recommended default values described on the FSAC's documentation will be used.\n  - If you are using a JSON configuration file though `g:LanguageClient_settingsPath`, the recommended default values will override the settings loaded from it.\n  - You can disable this by `let g:fsharp#use_recommended_server_config = 0`.\n\nSee [the documentation of FSAC](https://github.com/fsharp/FsAutoComplete#settings)\nfor the complete list of available settings. Frequently used ones are:\n\n##### Enable/disable automatic calling of `:FSharpLoadWorkspaceAuto` on opening F# files (default: enabled)\n\n~~~.vim\nlet g:fsharp#automatic_workspace_init = 1 \" 0 to disable.\n~~~\n\n##### Set the deep level of directory hierarchy when searching for sln/fsprojs (default: `2`)\n\n~~~.vim\nlet g:fsharp#workspace_mode_peek_deep_level = 2\n~~~\n\n##### Ignore specific directories when loading a workspace (default: empty)\n\n~~~.vim\nlet g:fsharp#exclude_project_directories = ['paket-files']\n~~~\n\n##### Enable/disable linter and unused opens/declarations analyzer (default: all enabled)\n\nYou may want to bind `LanguageClient#textDocument_codeAction()` to some shortcut key. Refer to their docs.\n\n~~~.vim\n\" 0 to disable.\nlet g:fsharp#linter = 1\nlet g:fsharp#unused_opens_analyzer = 1\nlet g:fsharp#unused_declarations_analyzer = 1\n~~~\n\n#### Editor Settings\n\n##### Enable/disable automatic calling of `:FSharpReloadWorkspace` on saving `fsproj` (default: enabled)\n\n~~~.vim\nlet g:fsharp#automatic_reload_workspace = 1 \" 0 to disable.\n~~~\n\n##### Show type signature at cursor position (default: enabled)\n\n~~~.vim\nlet g:fsharp#show_signature_on_cursor_move = 1 \" 0 to disable.\n~~~\n\n#### F# Interactive Settings\n\n##### Change the F# Interactive command to be used within Ionide-vim (default: `dotnet fsi`)\n\nIf you want to use a .NET Framework FSI instead of .NET Core one, set `g:fsharp#use_sdk_scripts` to `0`.\nSee: https://github.com/fsharp/FsAutoComplete/pull/466#issue-324869672\n\n~~~.vim\nlet g:fsharp#fsi_command = \"fsharpi\"\nlet g:fsharp#use_sdk_scripts = 0 \" for net462 FSI\n~~~\n\n##### Set additional runtime arguments passed to FSI (default: `[]` (empty))\n\nSets additional arguments of the FSI instance Ionide-vim spawns and changes the behavior of FSAC accordingly when editing fsx files.\n\n~~~.vim\nlet g:fsharp#fsi_extra_parameters = ['--langversion:preview']\n~~~\n\n##### Customize how FSI window is opened (default: `botright 10new`)\n\nIt must create a new empty window and then focus to it.\n\nSee [`:help opening-window`](http://vimdoc.sourceforge.net/htmldoc/windows.html#opening-window) for details.\n\n~~~.vim\nlet g:fsharp#fsi_window_command = \"botright vnew\"\n~~~\n\n##### Set if sending line/selection to FSI shoule make the cursor focus to FSI window (default: disabled)\n\nIf you are using Vim, you might want to enable this to see the result without inputting something.\n\n~~~.vim\nlet g:fsharp#fsi_focus_on_send = 1 \" 0 to not to focus.\n~~~\n\n##### Change the key mappings (default: `vscode`)\n\n* `vscode`:     Default. Same as in Ionide-VSCode (`Alt-Enter` to send, `Alt-@` to toggle terminal).\n  - `<M-CR>` in Neovim / `<ESC><CR>` in Vim: Sends line/selection to FSI.\n  - `<M-@>`  in Neovim / `<ESC>@`    in Vim: Toggles FSI window.\n* `vim-fsharp`: Same as in [fsharp/vim-fsharp](https://github.com/fsharp/vim-fsharp#fsharp-interactive). Note that `<leader>` is mapped to backslash by default. See [`:help mapleader`](http://vimdoc.sourceforge.net/htmldoc/map.html#mapleader).\n  - `<leader>i` : Sends line/selecion to FSI.\n  - `<leader>e` : Toggles FSI window.\n* `custom`:     You must set both `g:fsharp#fsi_keymap_send` and `g:fsharp#fsi_keymap_toggle` by yourself.\n  - `g:fsharp#fsi_keymap_send`   : Sends line/selection to FSI.\n  - `g:fsharp#fsi_keymap_toggle` : Toggles FSI window.\n* `none`:       Disables mapping.\n\n~~~.vim\n\" custom mapping example\nlet g:fsharp#fsi_keymap = \"custom\"\nlet g:fsharp#fsi_keymap_send   = \"<C-e>\"\nlet g:fsharp#fsi_keymap_toggle = \"<C-@>\"\n~~~\n\n### Advanced Tips\n\n#### Show tooltips on CursorHold\n\nIf you are using neovim 0.4.0 or later, floating windows will be used for tooltips and you might find it convenient to make them appear if the cursor does not move for several seconds.\n\n~~~.vim\nif has('nvim') && exists('*nvim_open_win')\n  augroup FSharpShowTooltip\n    autocmd!\n    autocmd CursorHold *.fs,*.fsi,*.fsx call fsharp#showTooltip()\n  augroup END\nendif\n~~~\n\nNote that you can set the delay time to show the tooltip by [`set updatetime=<ms>`](http://vimdoc.sourceforge.net/htmldoc/options.html#'updatetime'). The default delay is 4 seconds, which you may find too slow."},{"uri":"/Editors/Vim/getting_started.html","title":"Installation","content":"\n# Ionide-vim - Installation\n\n## Requirements\n\n* Neovim or Vim 8.0+ - Python support is not required as of now. This may or may not change in the future.\n* [.NET Core SDK](https://dotnet.microsoft.com/download) - required to run FsAutoComplete\n* [LanguageClient-neovim](https://github.com/autozimu/LanguageClient-neovim) - LSP client used to communicate with FsAutoComplete\n* [fzf](https://github.com/junegunn/fzf) (optional) -Optional dependency of LanguageClient-neovim, provides multi-entry selection UI\n\n## Getting Started\n\n### 1. Install [LanguageClient-neovim](https://github.com/autozimu/LanguageClient-neovim)\n\nRefer to [their INSTALL.md](https://github.com/autozimu/LanguageClient-neovim/blob/next/INSTALL.md).\n\n### 2. Install Ionide-vim\n\n#### Installing with your plugin manager\n\n##### [vim-plug](https://github.com/junegunn/vim-plug)\n\n~~~.vim\nPlug 'ionide/Ionide-vim', {\n      \\ 'do':  'make fsautocomplete',\n      \\}\n~~~\n\n##### [dein.vim](https://github.com/Shougo/dein.vim)\n\n~~~.vim\ncall dein#add('ionide/Ionide-vim', {\n    \\ 'build': 'make fsautocomplete',\n    \\ })\n~~~\n\n#### Installing manually\n\nClone Ionide-vim to some runtimepath and run `make fsautocomplete`.\n\n#### Installing on Windows\n\nRun `install.cmd`."},{"uri":"/Editors/Vim/overview.html","title":"Overview","content":"\n# Ionide-vim\n\n**GitHub link:** [https://github.com/ionide/Ionide-vim](https://github.com/ionide/Ionide-vim)\n**License:** [MIT](https://github.com/ionide/Ionide-vim/blob/master/LICENSE.md)\n\nIonide-vim is a F# plugin for Vim/Neovim. It's continuation of [fsharp/vim-fsharp](https://github.com/fsharp/vim-fsharp), powered by LSP protocol using [FsAutoComplete](/Tools/fsac.html). On the client side, it's powered by [autozimu/LanguageClient-neovim](https://github.com/autozimu/LanguageClient-neovim)\n\n\n<img class=\"gif\" src=\"/static/images/vim.gif\" />\n\n## List of features\n\n- Syntax highlighting\n- Auto completions\n- Error highlighting, error list, and quick fixes based on errors\n- Tooltips\n- Go to Definition\n- Find all references\n- Highlighting usages\n- Rename\n- Show symbols in file\n- Find symbol in workspace\n- Show signature in status line\n- Integration with F# Interactive **(new!)**\n- Integration with FSharpLint (additional hints and quick fixes) **(new!)**\n\n\n\n"}]